"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/visualizer/page",{

/***/ "(app-pages-browser)/./src/components/CrystalViewer.tsx":
/*!******************************************!*\
  !*** ./src/components/CrystalViewer.tsx ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CrystalViewer: () => (/* binding */ CrystalViewer)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_atoms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/atoms */ \"(app-pages-browser)/./src/lib/atoms.ts\");\n/* __next_internal_client_entry_do_not_use__ CrystalViewer auto */ \nvar _s = $RefreshSig$();\n\n\nfunction CrystalViewer(param) {\n    let { structureData, graphData, showEdges } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const viewerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const scriptLoadedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CrystalViewer.useEffect\": ()=>{\n            if (scriptLoadedRef.current || \"object\" === 'undefined') {\n                return;\n            }\n            const script = document.createElement('script');\n            script.src = 'https://3dmol.org/build/3Dmol-min.js';\n            script.async = true;\n            script.onload = ({\n                \"CrystalViewer.useEffect\": ()=>{\n                    scriptLoadedRef.current = true;\n                    if (containerRef.current && window.$3Dmol) {\n                        viewerRef.current = window.$3Dmol.createViewer(containerRef.current, {\n                            backgroundColor: '0x000000'\n                        });\n                    }\n                }\n            })[\"CrystalViewer.useEffect\"];\n            document.head.appendChild(script);\n        }\n    }[\"CrystalViewer.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CrystalViewer.useEffect\": ()=>{\n            if (!viewerRef.current || !structureData) {\n                return;\n            }\n            const viewer = viewerRef.current;\n            viewer.clear();\n            const { positions, atomTypes, elements } = structureData;\n            for(let i = 0; i < structureData.numAtoms; i++){\n                const x = positions[i * 3];\n                const y = positions[i * 3 + 1];\n                const z = positions[i * 3 + 2];\n                const elementIndex = atomTypes[i];\n                const element = elements[elementIndex];\n                const atomicNum = (0,_lib_atoms__WEBPACK_IMPORTED_MODULE_2__.getAtomicNumber)(element);\n                viewer.addSphere({\n                    center: {\n                        x,\n                        y,\n                        z\n                    },\n                    radius: (0,_lib_atoms__WEBPACK_IMPORTED_MODULE_2__.getRadiusByAtomicNumber)(atomicNum),\n                    color: (0,_lib_atoms__WEBPACK_IMPORTED_MODULE_2__.getColorByElementIndex)(elementIndex)\n                });\n            }\n            if (showEdges && graphData) {\n                const { edgeSources, edgeTargets } = graphData;\n                for(let i = 0; i < graphData.numEdges; i++){\n                    const src = edgeSources[i];\n                    const tgt = edgeTargets[i];\n                    if (src >= tgt) {\n                        continue;\n                    }\n                    viewer.addCylinder({\n                        start: {\n                            x: positions[src * 3],\n                            y: positions[src * 3 + 1],\n                            z: positions[src * 3 + 2]\n                        },\n                        end: {\n                            x: positions[tgt * 3],\n                            y: positions[tgt * 3 + 1],\n                            z: positions[tgt * 3 + 2]\n                        },\n                        radius: 0.025,\n                        color: '#4a4a4a',\n                        fromCap: false,\n                        toCap: false\n                    });\n                }\n            }\n            viewer.zoomTo();\n            viewer.zoom(0.8);\n            viewer.render();\n        }\n    }[\"CrystalViewer.useEffect\"], [\n        structureData,\n        graphData,\n        showEdges\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"h-full w-full\",\n        style: {\n            position: 'relative'\n        }\n    }, void 0, false, {\n        fileName: \"/home/bamarler/Github/Defect-GNN-cpp/web/src/components/CrystalViewer.tsx\",\n        lineNumber: 136,\n        columnNumber: 10\n    }, this);\n}\n_s(CrystalViewer, \"t5FxC2qygl93w1CdFoBAPzc+bEQ=\");\n_c = CrystalViewer;\nvar _c;\n$RefreshReg$(_c, \"CrystalViewer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NyeXN0YWxWaWV3ZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFFMEM7QUFFcUQ7QUEyQ3hGLFNBQVNLLGNBQWMsS0FJVDtRQUpTLEVBQzVCQyxhQUFhLEVBQ2JDLFNBQVMsRUFDVEMsU0FBUyxFQUNVLEdBSlM7O0lBSzVCLE1BQU1DLGVBQWVSLDZDQUFNQSxDQUFpQjtJQUM1QyxNQUFNUyxZQUFZVCw2Q0FBTUEsQ0FBZ0I7SUFDeEMsTUFBTVUsa0JBQWtCViw2Q0FBTUEsQ0FBQztJQUUvQkQsZ0RBQVNBO21DQUFDO1lBQ1IsSUFBSVcsZ0JBQWdCQyxPQUFPLElBQUksYUFBa0IsYUFBYTtnQkFDNUQ7WUFDRjtZQUVBLE1BQU1DLFNBQVNDLFNBQVNDLGFBQWEsQ0FBQztZQUN0Q0YsT0FBT0csR0FBRyxHQUFHO1lBQ2JILE9BQU9JLEtBQUssR0FBRztZQUNmSixPQUFPSyxNQUFNOzJDQUFHO29CQUNkUCxnQkFBZ0JDLE9BQU8sR0FBRztvQkFDMUIsSUFBSUgsYUFBYUcsT0FBTyxJQUFJTyxPQUFPQyxNQUFNLEVBQUU7d0JBQ3pDVixVQUFVRSxPQUFPLEdBQUdPLE9BQU9DLE1BQU0sQ0FBQ0MsWUFBWSxDQUFDWixhQUFhRyxPQUFPLEVBQUU7NEJBQ25FVSxpQkFBaUI7d0JBQ25CO29CQUNGO2dCQUNGOztZQUNBUixTQUFTUyxJQUFJLENBQUNDLFdBQVcsQ0FBQ1g7UUFDNUI7a0NBQUcsRUFBRTtJQUVMYixnREFBU0E7bUNBQUM7WUFDUixJQUFJLENBQUNVLFVBQVVFLE9BQU8sSUFBSSxDQUFDTixlQUFlO2dCQUN4QztZQUNGO1lBRUEsTUFBTW1CLFNBQVNmLFVBQVVFLE9BQU87WUFDaENhLE9BQU9DLEtBQUs7WUFFWixNQUFNLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFQyxRQUFRLEVBQUUsR0FBR3ZCO1lBRTNDLElBQUssSUFBSXdCLElBQUksR0FBR0EsSUFBSXhCLGNBQWN5QixRQUFRLEVBQUVELElBQUs7Z0JBQy9DLE1BQU1FLElBQUlMLFNBQVMsQ0FBQ0csSUFBSSxFQUFFO2dCQUMxQixNQUFNRyxJQUFJTixTQUFTLENBQUNHLElBQUksSUFBSSxFQUFFO2dCQUM5QixNQUFNSSxJQUFJUCxTQUFTLENBQUNHLElBQUksSUFBSSxFQUFFO2dCQUM5QixNQUFNSyxlQUFlUCxTQUFTLENBQUNFLEVBQUU7Z0JBQ2pDLE1BQU1NLFVBQVVQLFFBQVEsQ0FBQ00sYUFBYTtnQkFDdEMsTUFBTUUsWUFBWW5DLDJEQUFlQSxDQUFDa0M7Z0JBRWxDWCxPQUFPYSxTQUFTLENBQUM7b0JBQ2ZDLFFBQVE7d0JBQUVQO3dCQUFHQzt3QkFBR0M7b0JBQUU7b0JBQ2xCTSxRQUFRcEMsbUVBQXVCQSxDQUFDaUM7b0JBQ2hDSSxPQUFPdEMsa0VBQXNCQSxDQUFDZ0M7Z0JBQ2hDO1lBQ0Y7WUFFQSxJQUFJM0IsYUFBYUQsV0FBVztnQkFDMUIsTUFBTSxFQUFFbUMsV0FBVyxFQUFFQyxXQUFXLEVBQUUsR0FBR3BDO2dCQUVyQyxJQUFLLElBQUl1QixJQUFJLEdBQUdBLElBQUl2QixVQUFVcUMsUUFBUSxFQUFFZCxJQUFLO29CQUMzQyxNQUFNZCxNQUFNMEIsV0FBVyxDQUFDWixFQUFFO29CQUMxQixNQUFNZSxNQUFNRixXQUFXLENBQUNiLEVBQUU7b0JBRTFCLElBQUlkLE9BQU82QixLQUFLO3dCQUNkO29CQUNGO29CQUVBcEIsT0FBT3FCLFdBQVcsQ0FBQzt3QkFDakJDLE9BQU87NEJBQ0xmLEdBQUdMLFNBQVMsQ0FBQ1gsTUFBTSxFQUFFOzRCQUNyQmlCLEdBQUdOLFNBQVMsQ0FBQ1gsTUFBTSxJQUFJLEVBQUU7NEJBQ3pCa0IsR0FBR1AsU0FBUyxDQUFDWCxNQUFNLElBQUksRUFBRTt3QkFDM0I7d0JBQ0FnQyxLQUFLOzRCQUNIaEIsR0FBR0wsU0FBUyxDQUFDa0IsTUFBTSxFQUFFOzRCQUNyQlosR0FBR04sU0FBUyxDQUFDa0IsTUFBTSxJQUFJLEVBQUU7NEJBQ3pCWCxHQUFHUCxTQUFTLENBQUNrQixNQUFNLElBQUksRUFBRTt3QkFDM0I7d0JBQ0FMLFFBQVE7d0JBQ1JDLE9BQU87d0JBQ1BRLFNBQVM7d0JBQ1RDLE9BQU87b0JBQ1Q7Z0JBQ0Y7WUFDRjtZQUVBekIsT0FBTzBCLE1BQU07WUFDYjFCLE9BQU8yQixJQUFJLENBQUM7WUFDWjNCLE9BQU80QixNQUFNO1FBQ2Y7a0NBQUc7UUFBQy9DO1FBQWVDO1FBQVdDO0tBQVU7SUFFeEMscUJBQU8sOERBQUM4QztRQUFJQyxLQUFLOUM7UUFBYytDLFdBQVU7UUFBZ0JDLE9BQU87WUFBRUMsVUFBVTtRQUFXOzs7Ozs7QUFDekY7R0F6RmdCckQ7S0FBQUEiLCJzb3VyY2VzIjpbIi9ob21lL2JhbWFybGVyL0dpdGh1Yi9EZWZlY3QtR05OLWNwcC93ZWIvc3JjL2NvbXBvbmVudHMvQ3J5c3RhbFZpZXdlci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB0eXBlIHsgU3RydWN0dXJlRGF0YSwgR3JhcGhEYXRhIH0gZnJvbSAnQC9ob29rcy91c2VEZWZlY3RHTk4nO1xuaW1wb3J0IHsgZ2V0QXRvbWljTnVtYmVyLCBnZXRDb2xvckJ5RWxlbWVudEluZGV4LCBnZXRSYWRpdXNCeUF0b21pY051bWJlciB9IGZyb20gJ0AvbGliL2F0b21zJztcblxuaW50ZXJmYWNlIFZpZXdlciB7XG4gIGFkZFNwaGVyZTogKHNwZWM6IFNwaGVyZVNwZWMpID0+IHZvaWQ7XG4gIGFkZEN5bGluZGVyOiAoc3BlYzogQ3lsaW5kZXJTcGVjKSA9PiB2b2lkO1xuICBzZXRCYWNrZ3JvdW5kQ29sb3I6IChjb2xvcjogc3RyaW5nKSA9PiB2b2lkO1xuICB6b29tVG86ICgpID0+IHZvaWQ7XG4gIHpvb206IChmYWN0b3I6IG51bWJlcikgPT4gdm9pZDtcbiAgcmVuZGVyOiAoKSA9PiB2b2lkO1xuICBjbGVhcjogKCkgPT4gdm9pZDtcbn1cblxuaW50ZXJmYWNlIFNwaGVyZVNwZWMge1xuICBjZW50ZXI6IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IHo6IG51bWJlciB9O1xuICByYWRpdXM6IG51bWJlcjtcbiAgY29sb3I6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEN5bGluZGVyU3BlYyB7XG4gIHN0YXJ0OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyOyB6OiBudW1iZXIgfTtcbiAgZW5kOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyOyB6OiBudW1iZXIgfTtcbiAgcmFkaXVzOiBudW1iZXI7XG4gIGNvbG9yOiBzdHJpbmc7XG4gIGZyb21DYXA/OiBib29sZWFuO1xuICB0b0NhcD86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSAkM0Rtb2wge1xuICBjcmVhdGVWaWV3ZXI6IChlbGVtZW50OiBIVE1MRWxlbWVudCwgY29uZmlnOiB7IGJhY2tncm91bmRDb2xvcjogc3RyaW5nIH0pID0+IFZpZXdlcjtcbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICAkM0Rtb2w6ICQzRG1vbDtcbiAgfVxufVxuXG5pbnRlcmZhY2UgQ3J5c3RhbFZpZXdlclByb3BzIHtcbiAgc3RydWN0dXJlRGF0YTogU3RydWN0dXJlRGF0YSB8IG51bGw7XG4gIGdyYXBoRGF0YTogR3JhcGhEYXRhIHwgbnVsbDtcbiAgc2hvd0VkZ2VzOiBib29sZWFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQ3J5c3RhbFZpZXdlcih7XG4gIHN0cnVjdHVyZURhdGEsXG4gIGdyYXBoRGF0YSxcbiAgc2hvd0VkZ2VzLFxufTogQ3J5c3RhbFZpZXdlclByb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHtcbiAgY29uc3QgY29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3Qgdmlld2VyUmVmID0gdXNlUmVmPFZpZXdlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBzY3JpcHRMb2FkZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHNjcmlwdExvYWRlZFJlZi5jdXJyZW50IHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgc2NyaXB0LnNyYyA9ICdodHRwczovLzNkbW9sLm9yZy9idWlsZC8zRG1vbC1taW4uanMnO1xuICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgc2NyaXB0Lm9ubG9hZCA9ICgpOiB2b2lkID0+IHtcbiAgICAgIHNjcmlwdExvYWRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGlmIChjb250YWluZXJSZWYuY3VycmVudCAmJiB3aW5kb3cuJDNEbW9sKSB7XG4gICAgICAgIHZpZXdlclJlZi5jdXJyZW50ID0gd2luZG93LiQzRG1vbC5jcmVhdGVWaWV3ZXIoY29udGFpbmVyUmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcweDAwMDAwMCcsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9LCBbXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXZpZXdlclJlZi5jdXJyZW50IHx8ICFzdHJ1Y3R1cmVEYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgdmlld2VyID0gdmlld2VyUmVmLmN1cnJlbnQ7XG4gICAgdmlld2VyLmNsZWFyKCk7XG5cbiAgICBjb25zdCB7IHBvc2l0aW9ucywgYXRvbVR5cGVzLCBlbGVtZW50cyB9ID0gc3RydWN0dXJlRGF0YTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RydWN0dXJlRGF0YS5udW1BdG9tczsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gcG9zaXRpb25zW2kgKiAzXTtcbiAgICAgIGNvbnN0IHkgPSBwb3NpdGlvbnNbaSAqIDMgKyAxXTtcbiAgICAgIGNvbnN0IHogPSBwb3NpdGlvbnNbaSAqIDMgKyAyXTtcbiAgICAgIGNvbnN0IGVsZW1lbnRJbmRleCA9IGF0b21UeXBlc1tpXTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tlbGVtZW50SW5kZXhdO1xuICAgICAgY29uc3QgYXRvbWljTnVtID0gZ2V0QXRvbWljTnVtYmVyKGVsZW1lbnQpO1xuXG4gICAgICB2aWV3ZXIuYWRkU3BoZXJlKHtcbiAgICAgICAgY2VudGVyOiB7IHgsIHksIHogfSxcbiAgICAgICAgcmFkaXVzOiBnZXRSYWRpdXNCeUF0b21pY051bWJlcihhdG9taWNOdW0pLFxuICAgICAgICBjb2xvcjogZ2V0Q29sb3JCeUVsZW1lbnRJbmRleChlbGVtZW50SW5kZXgpLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHNob3dFZGdlcyAmJiBncmFwaERhdGEpIHtcbiAgICAgIGNvbnN0IHsgZWRnZVNvdXJjZXMsIGVkZ2VUYXJnZXRzIH0gPSBncmFwaERhdGE7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JhcGhEYXRhLm51bUVkZ2VzOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3JjID0gZWRnZVNvdXJjZXNbaV07XG4gICAgICAgIGNvbnN0IHRndCA9IGVkZ2VUYXJnZXRzW2ldO1xuXG4gICAgICAgIGlmIChzcmMgPj0gdGd0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2aWV3ZXIuYWRkQ3lsaW5kZXIoe1xuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICB4OiBwb3NpdGlvbnNbc3JjICogM10sXG4gICAgICAgICAgICB5OiBwb3NpdGlvbnNbc3JjICogMyArIDFdLFxuICAgICAgICAgICAgejogcG9zaXRpb25zW3NyYyAqIDMgKyAyXSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgeDogcG9zaXRpb25zW3RndCAqIDNdLFxuICAgICAgICAgICAgeTogcG9zaXRpb25zW3RndCAqIDMgKyAxXSxcbiAgICAgICAgICAgIHo6IHBvc2l0aW9uc1t0Z3QgKiAzICsgMl0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICByYWRpdXM6IDAuMDI1LFxuICAgICAgICAgIGNvbG9yOiAnIzRhNGE0YScsXG4gICAgICAgICAgZnJvbUNhcDogZmFsc2UsXG4gICAgICAgICAgdG9DYXA6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2aWV3ZXIuem9vbVRvKCk7XG4gICAgdmlld2VyLnpvb20oMC44KTtcbiAgICB2aWV3ZXIucmVuZGVyKCk7XG4gIH0sIFtzdHJ1Y3R1cmVEYXRhLCBncmFwaERhdGEsIHNob3dFZGdlc10pO1xuXG4gIHJldHVybiA8ZGl2IHJlZj17Y29udGFpbmVyUmVmfSBjbGFzc05hbWU9XCJoLWZ1bGwgdy1mdWxsXCIgc3R5bGU9e3sgcG9zaXRpb246ICdyZWxhdGl2ZScgfX0gLz47XG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwiZ2V0QXRvbWljTnVtYmVyIiwiZ2V0Q29sb3JCeUVsZW1lbnRJbmRleCIsImdldFJhZGl1c0J5QXRvbWljTnVtYmVyIiwiQ3J5c3RhbFZpZXdlciIsInN0cnVjdHVyZURhdGEiLCJncmFwaERhdGEiLCJzaG93RWRnZXMiLCJjb250YWluZXJSZWYiLCJ2aWV3ZXJSZWYiLCJzY3JpcHRMb2FkZWRSZWYiLCJjdXJyZW50Iiwic2NyaXB0IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3JjIiwiYXN5bmMiLCJvbmxvYWQiLCJ3aW5kb3ciLCIkM0Rtb2wiLCJjcmVhdGVWaWV3ZXIiLCJiYWNrZ3JvdW5kQ29sb3IiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJ2aWV3ZXIiLCJjbGVhciIsInBvc2l0aW9ucyIsImF0b21UeXBlcyIsImVsZW1lbnRzIiwiaSIsIm51bUF0b21zIiwieCIsInkiLCJ6IiwiZWxlbWVudEluZGV4IiwiZWxlbWVudCIsImF0b21pY051bSIsImFkZFNwaGVyZSIsImNlbnRlciIsInJhZGl1cyIsImNvbG9yIiwiZWRnZVNvdXJjZXMiLCJlZGdlVGFyZ2V0cyIsIm51bUVkZ2VzIiwidGd0IiwiYWRkQ3lsaW5kZXIiLCJzdGFydCIsImVuZCIsImZyb21DYXAiLCJ0b0NhcCIsInpvb21UbyIsInpvb20iLCJyZW5kZXIiLCJkaXYiLCJyZWYiLCJjbGFzc05hbWUiLCJzdHlsZSIsInBvc2l0aW9uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/CrystalViewer.tsx\n"));

/***/ })

});